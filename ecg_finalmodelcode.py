# -*- coding: utf-8 -*-
"""ECG_FINALMODELCODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qeg_fnI0ibsUKJqATJB5ZuIVpxPoFdkd
"""

# ===============================
# 1Ô∏è‚É£ MOUNT GOOGLE DRIVE
# ===============================
from google.colab import drive
drive.mount('/content/drive')

# ===============================
# 2Ô∏è‚É£ IMPORT LIBRARIES
# ===============================
import os
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
import cv2
import collections

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
from sklearn.utils.class_weight import compute_class_weight
from sklearn.metrics import classification_report, confusion_matrix

# ===============================
# 3Ô∏è‚É£ PATH & PARAMETERS
# ===============================
DATASET_PATH = "/content/drive/MyDrive/AI EL/ecgdataset/ecg data old version/train"

IMG_SIZE = 224
BATCH_SIZE = 32
EPOCHS = 60
NUM_CLASSES = 4

# ===============================
# 4Ô∏è‚É£ DATA GENERATORS (STRONG ECG-SAFE AUGMENTATION)
# ===============================
datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    zoom_range=0.15,
    width_shift_range=0.1,
    height_shift_range=0.1,
    brightness_range=[0.8, 1.2]
)

train_data = datagen.flow_from_directory(
    DATASET_PATH,
    target_size=(IMG_SIZE, IMG_SIZE),
    batch_size=BATCH_SIZE,
    class_mode='sparse',
    subset='training',
    shuffle=True
)

val_data = datagen.flow_from_directory(
    DATASET_PATH,
    target_size=(IMG_SIZE, IMG_SIZE),
    batch_size=BATCH_SIZE,
    class_mode='sparse',
    subset='validation',
    shuffle=False
)

print("Class indices:", train_data.class_indices)
print("Class distribution:", collections.Counter(train_data.classes))

# ===============================
# 5Ô∏è‚É£ CLASS WEIGHTS (CRITICAL)
# ===============================
labels = train_data.classes

class_weights = compute_class_weight(
    class_weight='balanced',
    classes=np.unique(labels),
    y=labels
)

class_weights = dict(enumerate(class_weights))
print("Class weights:", class_weights)

# ===============================
# 6Ô∏è‚É£ MODEL (EFFICIENTNET + FINE-TUNING)
# ===============================
base_model = EfficientNetB0(
    weights='imagenet',
    include_top=False,
    input_shape=(IMG_SIZE, IMG_SIZE, 3)
)

# üî• Fine-tune last layers for ECG learning
base_model.trainable = True
for layer in base_model.layers[:-30]:
    layer.trainable = False

x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(256, activation='relu')(x)
x = Dropout(0.5)(x)
output = Dense(NUM_CLASSES, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=output)

model.compile(
    optimizer=Adam(learning_rate=1e-4),
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

model.summary()

# ===============================
# 7Ô∏è‚É£ CALLBACKS (STABILITY)
# ===============================
callbacks = [
    EarlyStopping(patience=10, restore_best_weights=True),
    ReduceLROnPlateau(patience=5, factor=0.3)
]

# ===============================
# 8Ô∏è‚É£ TRAIN MODEL
# ===============================
history = model.fit(
    train_data,
    validation_data=val_data,
    epochs=EPOCHS,
    class_weight=class_weights,
    callbacks=callbacks
)

# ===============================
# 9Ô∏è‚É£ TRAINING CURVES
# ===============================
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.title("ECG Multi-Class Classification Accuracy")
plt.legend()
plt.show()

# ===============================
# üîü EVALUATION
# ===============================
val_data.reset()
preds = model.predict(val_data)
pred_classes = np.argmax(preds, axis=1)

print(classification_report(
    val_data.classes,
    pred_classes,
    target_names=list(val_data.class_indices.keys())
))

print("Confusion Matrix:")
print(confusion_matrix(val_data.classes, pred_classes))

# ===============================
# 1Ô∏è‚É£1Ô∏è‚É£ GRAD-CAM
# ===============================
def grad_cam(model, img_path, layer_name="block7a_project_conv"):
    img = tf.keras.preprocessing.image.load_img(
        img_path, target_size=(IMG_SIZE, IMG_SIZE)
    )
    img_array = tf.keras.preprocessing.image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    grad_model = Model(
        [model.inputs],
        [model.get_layer(layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        loss = tf.reduce_max(predictions)

    grads = tape.gradient(loss, conv_outputs)
    pooled_grads = tf.reduce_mean(grads, axis=(0,1,2))

    heatmap = tf.reduce_sum(pooled_grads * conv_outputs[0], axis=-1)
    heatmap = np.maximum(heatmap, 0) / np.max(heatmap)

    img = cv2.imread(img_path)
    heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))
    heatmap = cv2.applyColorMap(np.uint8(255*heatmap), cv2.COLORMAP_JET)

    plt.imshow(cv2.cvtColor(cv2.addWeighted(img,0.6,heatmap,0.4,0), cv2.COLOR_BGR2RGB))
    plt.axis("off")
    plt.show()

# ===============================
# 1Ô∏è‚É£2Ô∏è‚É£ UPLOAD & PREDICT (TOP-2 OUTPUT)
# ===============================
from google.colab import files

def upload_and_predict_ecg(model):
    uploaded = files.upload()
    img_path = list(uploaded.keys())[0]

    img = tf.keras.preprocessing.image.load_img(
        img_path, target_size=(IMG_SIZE, IMG_SIZE)
    )
    img_array = tf.keras.preprocessing.image.img_to_array(img)/255.0
    img_array = np.expand_dims(img_array, axis=0)

    preds = model.predict(img_array)[0]
    class_map = {v:k for k,v in train_data.class_indices.items()}

    top2 = np.argsort(preds)[-2:][::-1]
    for i in top2:
        print(f"{class_map[i]}: {preds[i]*100:.2f}%")

    plt.imshow(cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB))
    plt.axis("off")
    plt.show()

upload_and_predict_ecg(model)

# ===============================
# 1Ô∏è‚É£3Ô∏è‚É£ SAVE MODEL
# ===============================
model.save("ecg_model_multiclass_finetuned.keras")
print("‚úÖ Model saved as ecg_model_multiclass_finetuned.keras")

upload_and_predict_ecg(model)

upload_and_predict_ecg(model)